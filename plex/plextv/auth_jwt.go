package plextv

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/lestrrat-go/jwx/v3/jwa"
	"github.com/lestrrat-go/jwx/v3/jwk"
	"github.com/lestrrat-go/jwx/v3/jws"
	"github.com/lestrrat-go/jwx/v3/jwt"
)

// GenerateAndUploadPublicKey is a helper function to set up JWT Tokens.
// It generates a new ed25519 keypair, uploads the private key to the Plex server and
// returns the private key and associated public key ID to be used for generating a new JWT token.
//
// Token must be a valid Plex token, either generated by [Config.RegisterWithCredentials]/[Config.RegisterWithPIN] or
// obtained from a previous [Config.JWTToken] call.
func (c Config) GenerateAndUploadPublicKey(ctx context.Context, token Token) (ed25519.PrivateKey, string, error) {
	publicKey, privateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, "", fmt.Errorf("generate keypair: %w", err)
	}
	keyID, err := c.UploadPublicKey(ctx, publicKey, token)
	return privateKey, keyID, err
}

// UploadPublicKey uploads a public key to the Plex server. It returns a generated key ID for the public key,
// which can be used to generate a new token with [Config.JWTToken].
func (c Config) UploadPublicKey(ctx context.Context, publicKey ed25519.PublicKey, token Token) (string, error) {
	// check we have a valid token
	// TODO: IsValid should return err, not bool, so the caller can determine the root cause of the error.
	if !token.IsValid() {
		return "", ErrInvalidToken
	}

	// create a jwk from the public key
	jwKey, err := jwk.Import(publicKey)
	if err != nil {
		return "", fmt.Errorf("import key: %w", err)
	}
	// Assign a key ID (kid) using thumbprint
	if err = jwk.AssignKeyID(jwKey); err != nil {
		return "", fmt.Errorf("assign key id: %w", err)
	}
	keyID, _ := jwKey.KeyID()
	// Set use (sig) and algorithm
	_ = jwKey.Set(jwk.KeyUsageKey, "sig")
	_ = jwKey.Set(jwk.KeyIDKey, keyID)
	_ = jwKey.Set(jwk.AlgorithmKey, jwa.EdDSA().String())

	// Marshal to JSON
	jwkBody, _ := json.Marshal(map[string]any{"jwk": jwKey})

	// upload the key to the Plex server
	resp, err := c.do(ctx, http.MethodPost, c.V2URL+"/api/v2/auth/jwk", bytes.NewReader(jwkBody), http.StatusCreated, func(req *http.Request) {
		req.Header.Set("X-Plex-Token", token.String())
	})
	if err != nil {
		return "", fmt.Errorf("jwk: %w", err)
	}
	_ = resp.Body.Close()
	return keyID, nil
}

// JWTToken is a new authentication mechanism introduced in plex.tv, based on JSON Web Tokens (JWT).
//
// JWTTokens increase security by eliminating the need for a PIN or username/password combination each time
// a client starts. As setting up JWT requires a valid token, a client only needs to register once.
//
// To create a JWTToken, a client generates a new ed25519 keypair and uploads the public key to Plex
// (using [Config.GenerateAndUploadPublicKey] or [Config.UploadPublicKey], using a valid Plex token).
// The client can then use the private key and the public key's ID to generate a new JWTToken.
//
// This does require persistence, as the Client ID, private key, and public key ID must be kept in sync
// with plex.tv: once a JWTToken has been requested for the ClientID, further requests to re-register that ClientID
// ([Config.RegisterWithCredentials]/[Config.RegisterWithPIN]) will fail. You will need to generate a new ClientID
// and re-register.
//
// JWTTokens are valid for 7 days.
//
// Note: a JWTToken can only be used to access the plex.tv API; it cannot be used to access Plex Media Servers.
func (c Config) JWTToken(ctx context.Context, privateKey ed25519.PrivateKey, keyID string) (Token, error) {
	nonce, err := c.nonce(ctx)
	if err != nil {
		return "", fmt.Errorf("get nonce: %w", err)
	}
	// create a jwt
	tok := jwt.New()
	_ = tok.Set("nonce", nonce)
	_ = tok.Set("scope", strings.Join(c.Scopes, ","))
	_ = tok.Set("aud", c.aud)
	_ = tok.Set("iss", c.ClientID)
	headers := jws.NewHeaders()
	_ = headers.Set(jws.KeyIDKey, keyID)
	signed, err := jwt.Sign(tok,
		jwt.WithKey(
			jwa.EdDSA(),
			privateKey,
			jws.WithProtectedHeaders(headers),
		),
	)
	if err != nil {
		return "", fmt.Errorf("sign: %w", err)
	}

	// request a new jwtToken
	return c.jwtToken(ctx, string(signed))
}

func (c Config) nonce(ctx context.Context) (string, error) {
	resp, err := c.do(ctx, http.MethodGet, c.V2URL+"/api/v2/auth/nonce", nil, http.StatusOK)
	if err != nil {
		return "", err
	}
	defer func() { _ = resp.Body.Close() }()

	var response struct {
		Nonce string `json:"nonce"`
	}
	if err = json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return "", fmt.Errorf("decode: %w", err)
	}
	return response.Nonce, nil
}

func (c Config) jwtToken(ctx context.Context, signedJWToken string) (Token, error) {
	// send the signed token to the auth endpoint
	var body bytes.Buffer
	_ = json.NewEncoder(&body).Encode(map[string]string{"jwt": signedJWToken})
	resp, err := c.do(ctx, http.MethodPost, c.V2URL+"/api/v2/auth/token", &body, http.StatusOK)
	if err != nil {
		return "", err
	}
	defer func() { _ = resp.Body.Close() }()

	// extract the new token from the response
	var response struct {
		AuthToken string `json:"auth_token"`
	}
	if err = json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return "", fmt.Errorf("decode: %w", err)
	}
	return Token(response.AuthToken), nil
}
