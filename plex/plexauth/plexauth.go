package plexauth

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/clambin/mediaclients/plex/plexhttp"
	"github.com/golang-jwt/jwt/v5"
	"github.com/lestrrat-go/jwx/v3/jwa"
	"github.com/lestrrat-go/jwx/v3/jwk"
)

var (
	defaultHTTPClient = &http.Client{
		Timeout:   15 * time.Second,
		Transport: http.DefaultTransport,
	}
)

type httpClientType struct{}

func WithHTTPClient(ctx context.Context, httpClient *http.Client) context.Context {
	return context.WithValue(ctx, httpClientType{}, httpClient)
}

func httpClient(ctx context.Context) *http.Client {
	if c, ok := ctx.Value(httpClientType{}).(*http.Client); ok {
		return c
	}
	return defaultHTTPClient
}

// DefaultAuthConfig contains the default configuration required to authenticate with Plex.
var DefaultAuthConfig = AuthConfig{
	AuthURL:   "https://plex.tv/users/sign_in.xml",
	AuthV2URL: "https://clients.plex.tv",
	TokenTTL:  7 * 24 * time.Hour,
	Scope:     "username,email,friendly_name",
	aud:       "plex.tv",
}

// AuthConfig contains the configuration required to authenticate with Plex.
type AuthConfig struct {
	// AuthURL is the full URL of the legacy Plex authentication endpoint.
	// It is used for initial username/password authentication.
	// This should normally not be changed.
	AuthURL string
	// AuthV2URL is the base URL of the new Plex authentication endpoint.
	// This should normally not be changed.
	AuthV2URL string
	// ClientID is the unique identifier of the client application.
	ClientID string
	// Scope is a comma-separated list of scopes to request.
	// Leaving this public for future use, although it is unlikely to need to be changed.
	Scope string
	aud   string
	// Device information used during username/password authentication.
	Device Device
	// TokenTTL is the duration of the authentication token.
	// Defaults to 7 days, in line with Plex specifications.
	// Normally, this should not need to be changed.
	TokenTTL time.Duration
}

// WithClientID sets the client ID.
func (a AuthConfig) WithClientID(clientID string) AuthConfig {
	a.ClientID = clientID
	return a
}

// WithDevice sets the device information used during username/password authentication.
// See the [Device] type for details on what each field means.
func (a AuthConfig) WithDevice(device Device) AuthConfig {
	a.Device = device
	return a
}

// WithTokenTTL sets the duration of the authentication token.
func (a AuthConfig) WithTokenTTL(ttl time.Duration) AuthConfig {
	a.TokenTTL = ttl
	return a
}

// AuthorizeDevice authenticates with Plex using the legacy username/password authentication endpoint and
// returns a valid Plex token.
//
// This is the only implemented authentication method when an application does not yet have a valid token.
// After a successful authentication, the token should be managed by uploading a public key to the Plex server through
// [AuthConfig.GenerateAndUploadPublicKey] or [AuthConfig.UploadPublicKey] and refreshed using [AuthConfig.GetAuthToken].
func (a AuthConfig) AuthorizeDevice(ctx context.Context, username, password string) (string, error) {
	// credentials are passed in the request body, as url-encoded form
	v := make(url.Values)
	v.Set("user[login]", username)
	v.Set("user[password]", password)

	// call the auth endpoint
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, a.AuthURL, bytes.NewBufferString(v.Encode()))
	if err != nil {
		return "", fmt.Errorf("new request: %w", err)
	}
	a.Device.populateRequest(req)
	req.Header.Set("X-Plex-Client-Identifier", a.ClientID)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("Accept", "application/xml")
	resp, err := httpClient(ctx).Do(req)
	if err != nil {
		return "", err
	}
	defer func() { _ = resp.Body.Close() }()

	// a successful response contains an XML document with an authentication token
	if resp.StatusCode != http.StatusCreated {
		return "", plexhttp.Parse(resp)
	}
	var authResponse struct {
		XMLName             xml.Name `xml:"user"`
		AuthenticationToken string   `xml:"authenticationToken,attr"`
	}
	err = xml.NewDecoder(resp.Body).Decode(&authResponse)
	return authResponse.AuthenticationToken, err
}

// GenerateAndUploadPublicKey is a helper function that generates a new ed25519 keypair, uploads the private key to
// the Plex server and returns the private key and associated public key ID, to be used for generating a new Token.
//
// Token must be a valid Plex token, either generated by [AuthConfig.AuthorizeDevice] or
// obtained from a previous [AuthConfig.GetAuthToken] call.
func (a AuthConfig) GenerateAndUploadPublicKey(ctx context.Context, token string) (ed25519.PrivateKey, string, error) {
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, "", fmt.Errorf("generate keypair: %w", err)
	}
	keyID, err := a.UploadPublicKey(ctx, pub, token)
	return priv, keyID, err
}

// UploadPublicKey uploads a public key to the Plex server. It returns a generated key ID for the public key,
// which can be used to generate a new token with [AuthConfig.GetAuthToken].
func (a AuthConfig) UploadPublicKey(ctx context.Context, publicKey ed25519.PublicKey, token string) (string, error) {
	// create a jwk from the public key
	jwKey, err := jwk.Import(publicKey)
	if err != nil {
		return "", fmt.Errorf("import key: %w", err)
	}
	// Assign a key ID (kid) using thumbprint
	if err = jwk.AssignKeyID(jwKey); err != nil {
		return "", fmt.Errorf("assign key id: %w", err)
	}
	keyID, _ := jwKey.KeyID()
	// Set use (sig) and algorithm
	_ = jwKey.Set(jwk.KeyUsageKey, "sig")
	_ = jwKey.Set(jwk.KeyIDKey, keyID)
	_ = jwKey.Set(jwk.AlgorithmKey, jwa.EdDSA().String())

	// Marshal to JSON
	jwkBody, _ := json.Marshal(map[string]any{"jwk": jwKey})

	// upload the key to the Plex server
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, a.AuthV2URL+"/api/v2/auth/jwk", bytes.NewReader(jwkBody))
	if err != nil {
		return "", fmt.Errorf("new request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("X-Plex-Client-Identifier", a.ClientID)
	req.Header.Set("X-Plex-Token", token)
	resp, err := httpClient(ctx).Do(req)
	if err != nil {
		return "", plexhttp.Parse(resp)
	}
	defer func() { _ = resp.Body.Close() }()
	if resp.StatusCode != http.StatusCreated {
		return "", plexhttp.Parse(resp)
	}
	return keyID, nil
}

// GetAuthToken generates a new authentication token using the provided private key (for the uploaded public key)
// and key ID (returned by [AuthConfig.GenerateAndUploadPublicKey] or [AuthConfig.UploadPublicKey]).
func (a AuthConfig) GetAuthToken(ctx context.Context, privateKey ed25519.PrivateKey, keyID string) (string, error) {
	nonce, err := a.getNonce(ctx)
	if err != nil {
		return "", fmt.Errorf("get nonce: %w", err)
	}
	// create a jwt
	now := time.Now()
	token := jwt.NewWithClaims(jwt.SigningMethodEdDSA, jwt.MapClaims{
		"nonce": nonce,
		"scope": a.Scope,
		"aud":   a.aud,
		"iss":   a.ClientID,
		"iat":   now.Unix(),
		"exp":   now.Add(a.TokenTTL).Unix(),
	})
	// kid has to be in the header, not the claims.
	token.Header["kid"] = keyID

	// sign the token
	signedToken, err := token.SignedString(privateKey)
	if err != nil {
		return "", fmt.Errorf("sign: %w", err)
	}

	return a.requestToken(ctx, signedToken)
}

func (a AuthConfig) getNonce(ctx context.Context) (string, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, a.AuthV2URL+"/api/v2/auth/nonce", nil)
	if err != nil {
		return "", fmt.Errorf("new request: %w", err)
	}
	req.Header.Set("X-Plex-Client-Identifier", a.ClientID)
	req.Header.Set("Accept", "application/json")
	resp, err := httpClient(ctx).Do(req)
	if err != nil {
		return "", plexhttp.Parse(resp)
	}
	defer func() { _ = resp.Body.Close() }()
	if resp.StatusCode != http.StatusOK {
		return "", plexhttp.Parse(resp)
	}

	var response struct {
		Nonce string `json:"nonce"`
	}
	if err = json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return "", fmt.Errorf("decode: %w", err)
	}
	return response.Nonce, nil
}

func (a AuthConfig) requestToken(ctx context.Context, signedToken string) (string, error) {
	// send the signed token to the auth endpoint
	var body bytes.Buffer
	if err := json.NewEncoder(&body).Encode(map[string]string{"jwt": signedToken}); err != nil {
		return "", fmt.Errorf("encode: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, a.AuthV2URL+"/api/v2/auth/token", &body)
	if err != nil {
		return "", fmt.Errorf("new request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("X-Plex-Client-Identifier", a.ClientID)
	resp, err := httpClient(ctx).Do(req)
	if err != nil {
		return "", plexhttp.Parse(resp)
	}
	defer func() { _ = resp.Body.Close() }()
	if resp.StatusCode != http.StatusOK {
		b, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("post: unexpected status code: %d - %s (%s)", resp.StatusCode, resp.Status, string(b))
	}

	// extract the new token from the response
	var response struct {
		AuthToken string `json:"auth_token"`
	}
	if err = json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return "", fmt.Errorf("decode: %w", err)
	}
	return response.AuthToken, nil
}

// Device identifies the client when using Plex username/password credentials.
// Although this package provides a default, it is recommended to set this yourself.
type Device struct {
	// Product is the name of the client product.
	// Passed as X-Plex-Product header.
	// In Authorized Devices, it is shown on line 3.
	Product string
	// Version is the version of the client application.
	// Passed as X-Plex-Version header.
	// In Authorized Devices, it is shown on line 2.
	Version string
	// Platform is the operating system or compiler of the client application.
	// Passed as X-Plex-Platform header.
	Platform string
	// PlatformVersion is the version of the platform.
	// Passed as X-Plex-Platform-Version header.
	PlatformVersion string
	// Device is a relatively friendly name for the client device.
	// Passed as X-Plex-Device header.
	// In Authorized Devices, it is shown on line 4.
	Device string
	// Model is a potentially less friendly identifier for the device model.
	// Passed as X-Plex-Model header.
	Model string
	// DeviceVendor is the name of the device vendor.
	// Passed as X-Plex-Device-Vendor header.
	DeviceVendor string
	// DeviceName is a friendly name for the client.
	// Passed as X-Plex-Device-Name header.
	// In Authorized Devices, it is shown on line 1.
	DeviceName string
}

func (id Device) populateRequest(req *http.Request) {
	headers := map[string]string{
		"X-Plex-Product":          id.Product,
		"X-Plex-Version":          id.Version,
		"X-Plex-Platform":         id.Platform,
		"X-Plex-Platform-Version": id.PlatformVersion,
		"X-Plex-Device":           id.Device,
		"X-Plex-Device-Vendor":    id.DeviceVendor,
		"X-Plex-Device-Name":      id.DeviceName,
		"X-Plex-Model":            id.Model,
	}
	for key, value := range headers {
		if value != "" {
			req.Header.Set(key, value)
		}
	}
}
